<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="MAIN" Id="{3fa504f6-db2b-4889-a5d5-d9357cd86edc}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	// [BL BR TL TR] 
	axes : ARRAY[0..3] OF AXIS_REF; // (linked in MOTION)
	
	mcResets        : ARRAY[0..3] OF MC_Reset;
	mcPowers        : ARRAY[0..3] OF MC_Power;
	mcSetPositions  : ARRAY[0..3] OF MC_SetPosition;
	mcMoveAbsolutes : ARRAY[0..3] OF MC_MoveAbsolute;
	mcMoveRelatives : ARRAY[0..3] OF MC_MoveRelative;
	mcMoveVelocitys : ARRAY[0..3] OF MC_MoveVelocity;
	mcHalts         : ARRAY[0..3] OF MC_Halt;
	mcGearIns       : ARRAY[1..3] OF MC_GearIn;
	mcGearOuts      : ARRAY[1..3] OF MC_GearOut;
	mcPhaseAbss     : ARRAY[1..3] OF MC_PhasingAbsolute;
	
	readAcc : read_accelerometer;
	readGeo : read_geophone;
	
	tempCtrl : FB_SimpleTempCtrl;

	i: INT;
	j: INT;
	endIdx : INT := 3;
	started : BOOL := FALSE;
	coupled : BOOL := FALSE;
	inCPhase : BOOL := FALSE;
	inUCPhase : BOOL := FALSE;
	mode : INT := 1; // 0 = move abs, 1 = move rel, 2 = move vel
	
	relsDone : ARRAY[0..3] OF BOOL; // keep track of if each motor is done its relative movement
	
	// MAIN BOOL
	runState : BOOL := FALSE;
	
	// toggles
	togStart : BOOL := FALSE;
	togStop : BOOL := TRUE;
	togCoup : BOOL := FALSE;
	togAbsPos : BOOL := FALSE;
	togRelPos : BOOL := FALSE;
	togVel : BOOL := TRUE;
	
	// values in HMI
	txtPos : INT := 0;
	txtVel : INT := 200;
	txtAcc : INT := 100;
	txtPhs : INT := 0;
	
	// keep track of changes
	prevPos : INT := txtPos;
	prevVel : INT := txtVel;
	prevAcc : INT := txtAcc;
	prevPhs : INT := txtPhs;
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[FOR i := 0 TO 3 DO
	axes[i].ReadStatus();
END_FOR

readAcc();
readGeo();

// on off logic
// prevent turning off a button, only swapping allowed
IF runState AND NOT togStop THEN
	togStart := TRUE;
ELSIF NOT runState AND NOT togStart THEN
	togStop := TRUE;
END_IF

IF NOT runState AND togStart THEN 
	togStop := FALSE;
	runState := TRUE;
END_IF
// always have stop check last
IF runState AND togStop THEN
	togStart := FALSE;
	runState := FALSE;
END_IF


// prevent no mode selection
IF NOT togAbsPos AND mode = 0 THEN
	togAbsPos := TRUE;
ELSIF NOT togRelPos AND mode = 1 THEN
	togRelPos := TRUE;
ELSIF NOT togVel AND mode = 2 THEN
	togVel := TRUE;
END_IF

// switch modes
IF togAbsPos AND mode <> 0 THEN
	togRelPos := FALSE;
	togVel := FALSE;
	mode := 0;
ELSIF togRelPos AND mode <> 1 THEN
	togAbsPos := FALSE;
	togVel := FALSE;
	mode := 1;
ELSIF togVel AND mode <> 2 THEN
	togAbsPos := FALSE;
	togRelPos := FALSE;
	mode := 2;
END_IF


// disallow coupling while in motion
IF (axes[0].Status.Moving OR axes[1].Status.Moving OR axes[2].Status.Moving OR axes[3].Status.Moving) AND togCoup AND NOT coupled THEN
	togCoup := FALSE;
END_IF

// COUPLE/UNCOUPLE GEARS
mcGearOuts[1](Slave:=axes[1], Execute:=NOT togCoup AND coupled);
mcGearOuts[2](Slave:=axes[2], Execute:=NOT togCoup AND coupled);
mcGearOuts[3](Slave:=axes[3], Execute:=NOT togCoup AND coupled);
mcGearIns[1](Master:=axes[0], Slave:=axes[1], Execute:=togCoup AND NOT coupled, RatioNumerator:=-1); // reverse gear BR with BL
mcGearIns[2](Master:=axes[0], Slave:=axes[2], Execute:=togCoup AND NOT coupled, RatioNumerator:=1); // gear TL with BL
mcGearIns[3](Master:=axes[2], Slave:=axes[3], Execute:=togCoup AND NOT coupled, RatioNumerator:=-1); // reverse gear TR with TL

// check if uncoupling done
IF (NOT togCoup AND coupled) AND (mcGearOuts[1].Done AND mcGearOuts[2].Done AND mcGearOuts[3].Done) THEN
	endIdx := 3;
	coupled := FALSE;
END_IF
// check if coupling done
IF (togCoup AND NOT coupled) AND (mcGearIns[1].InGear AND mcGearIns[2].InGear AND mcGearIns[3].InGear) THEN
	endIdx := 0;
	coupled := TRUE;
END_IF


// startup
IF NOT started THEN
	FOR i := 0 TO 3 DO
		// default to OFF despite variable values (safety)
		togStart := FALSE;
		togStop := TRUE;
		runState := FALSE;
		mcResets[i](Axis:=axes[i]);
		mcPowers[i](Axis:=axes[i], Enable:= TRUE, Enable_Positive:=TRUE, Enable_Negative:=TRUE);
			
		// if all motors powered, set to started
		IF mcPowers[0].Status AND mcPowers[1].Status AND mcPowers[2].Status AND mcPowers[3].Status THEN
			started := TRUE;
		END_IF
	END_FOR
END_IF


// if all motors powered up, enter main loop
IF started THEN
	// set phase, master = BL, slave = TL

	// if uncoupled, allign the axes AT 0 phase again
	IF runState AND coupled THEN
		mcPhaseAbss[1](Master:=axes[0], Slave:=axes[1], Execute:=TRUE, PhaseShift:=0, Velocity:=txtVel+200); // set phase of BR w BL
		mcPhaseAbss[2](Master:=axes[0], Slave:=axes[2], Execute:=TRUE, PhaseShift:=txtPhs, Velocity:=txtVel+200); // set phase of top w bottom
		mcPhaseAbss[3](Master:=axes[2], Slave:=axes[3], Execute:=TRUE, PhaseShift:=0, Velocity:=txtVel+200); // set phase of TR w TL
	ELSIF runState AND NOT coupled THEN
		mcPhaseAbss[1](Master:=axes[0], Slave:=axes[1], Execute:=TRUE, PhaseShift:=0, Velocity:=txtVel+200);
		mcPhaseAbss[2](Master:=axes[0], Slave:=axes[2], Execute:=TRUE, PhaseShift:=0, Velocity:=txtVel+200);
		mcPhaseAbss[3](Master:=axes[2], Slave:=axes[3], Execute:=TRUE, PhaseShift:=0, Velocity:=txtVel+200);
	END_IF
	
	
	FOR i := 0 TO endIdx DO
		
		// if values have been updated, unexecute relevant functions so that they can restart with correct values
		IF (prevVel <> txtVel) OR (prevAcc <> txtAcc) THEN
			mcMoveAbsolutes[i](Axis:=axes[i], Execute:=FALSE);
			mcMoveRelatives[i](Axis:=axes[i], Execute:=FALSE);
			mcMoveVelocitys[i](Axis:=axes[i], Execute:=FALSE);
		ELSIF prevPos <> txtPos THEN
			mcMoveAbsolutes[i](Axis:=axes[i], Execute:=FALSE);
			mcMoveRelatives[i](Axis:=axes[i], Execute:=FALSE);
		END_IF
		// if last index then set the previous values for change checks above ^
		IF i = endIdx THEN
			prevPos := txtPos;
			prevVel := txtVel;
			prevAcc := txtAcc;
		END_IF
		
		// check if relative movement is done, set to stop
		IF mcMoveRelatives[i].Done  THEN
			relsDone[i] := TRUE;
			FOR j := 0 TO 3 DO
				IF relsDone[i] := FALSE THEN EXIT; END_IF
				IF i = 3 THEN
					togStop := TRUE;
					togStart := FALSE;
					runState := FALSE;
					relsDone[0] := FALSE;
					relsDone[1] := FALSE;
					relsDone[2] := FALSE;
				END_IF
			END_FOR
		END_IF
		
		// run main operations, execute values based on various bools
		mcSetPositions[i](Axis:= axes[i], Execute:= TRUE, Position:= 0); // is this needed?
		mcMoveAbsolutes[i](Axis:=axes[i], Execute:=togAbsPos AND runState, Position:=txtPos, Velocity:=txtVel, Acceleration:=txtAcc, Deceleration:=txtAcc);
		mcMoveRelatives[i](Axis:=axes[i], Execute:=togRelPos AND runState AND NOT relsDone[i], Distance:=txtPos, Velocity:=txtVel, Acceleration:=txtAcc, Deceleration:=txtAcc);
		mcMoveVelocitys[i](Axis:=axes[i], Execute:=togVel AND runState, Velocity:=txtVel, Acceleration:=txtAcc, Deceleration:=txtAcc);
		
		mcHalts[i](Axis:=axes[i],Execute:=NOT runState);
	END_FOR
	
	// always perform halt last, nothing should ever override halt command
//	mcHalts[1](Axis:=axes[1],Execute:=NOT runState);
//	mcHalts[2](Axis:=axes[2],Execute:=NOT runState);
//	mcHalts[3](Axis:=axes[3],Execute:=NOT runState);
END_IF
]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="1218" Count="3" />
      <LineId Id="1442" Count="0" />
      <LineId Id="1498" Count="0" />
      <LineId Id="1222" Count="60" />
      <LineId Id="1381" Count="0" />
      <LineId Id="1284" Count="3" />
      <LineId Id="1380" Count="0" />
      <LineId Id="1289" Count="23" />
      <LineId Id="1378" Count="0" />
      <LineId Id="1315" Count="0" />
      <LineId Id="1385" Count="0" />
      <LineId Id="1388" Count="1" />
      <LineId Id="1386" Count="1" />
      <LineId Id="1316" Count="2" />
      <LineId Id="1326" Count="41" />
      <LineId Id="1382" Count="1" />
      <LineId Id="1368" Count="2" />
      <LineId Id="1372" Count="3" />
      <LineId Id="452" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>